extends c

global !p

def write_docstring_args(arglist, snip):
	args = str(arglist).split(',')

	if len(args) > 1:
		c = 0
		for arg in args:
			if c == 0:
				snip.rv += arg
				c = 1
			else:
				snip += '*       : %s' % arg.strip()
	else:
		snip.rv = args[0]


endglobal

###########################################################################
#                            TextMate Snippets                            #
###########################################################################

snippet incc "Description" b
#include <${1:iostream}>
endsnippet
snippet inc "current headfile" b
#include "${1:iostream}"
endsnippet
snippet binc "boost headfile" b
#include <boost/${1:shared_ptr}.hpp>
endsnippet

snippet msp "std::shared_ptr" b
std::shared_ptr<${1:T}> ${2} = std::make_shared<$1>(${3});
endsnippet

snippet mup "std::unique_ptr" b
std::unique_ptr<${1:T}> ${2} = std::make_unique<$1>(${3});
endsnippet

snippet cout "std::cout"
std::cout << ${1} << std::endl;
endsnippet
snippet cin "std::cin"
std::cin >> ${1};
endsnippet

# cast
snippet sca "static cast"
static_cast<${1:unsigned}>(${2:expr})${3}
endsnippet
snippet dca "dynamic cast"
dynamic_cast<${1:unsigned}>(${2:expr})${3}
endsnippet
snippet rca "reinterpret"
reinterpret_cast<${1:unsigned}>(${2:expr})${3}
endsnippet
snippet cca "const cast"
const_cast<${1:unsigned}>(${2:expr})${3}
endsnippet

snippet beginend "$1.begin(), $1.end() (beginend)"
${1:v}${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}begin(), $1${1/^.*?(-)?(>)?$/(?2::(?1:>:.))/}end()
endsnippet

snippet cl "class .. (class)"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
	${1/(\w+).*/$1/} (${2:arguments});
	virtual ~${1/(\w+).*/$1/} ();

private:
	${0:/* data */}
};
endsnippet

snippet ns "namespace .. (namespace)"
namespace${1/.+/ /m}${1:`!p snip.rv = snip.basename or "name"`}
{
	${VISUAL}$0
}${1/.+/ \/* /m}$1${1/.+/ *\/ /m}
endsnippet

snippet readfile "read file (readF)"
std::vector<char> v;
if (FILE *fp = fopen(${1:"filename"}, "r"))
{
	char buf[1024];
	while(size_t len = fread(buf, 1, sizeof(buf), fp))
		v.insert(v.end(), buf, buf + len);
	fclose(fp);
}
endsnippet

snippet map "std::map (map)"
std::map<${1:key}, ${2:value}> map$0;
endsnippet

snippet vector "std::vector (v)"
std::vector<${1:char}> v$0;
endsnippet

snippet tp "template <typename ..> (template)"
template <typename ${1:_InputIter}>
endsnippet


# foreach
snippet fore "foreach"
for (${1:auto} ${2:i} : ${3:container}) {
	${4}
}
endsnippet

snippet iter "iterator"
for (${1:std::vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4) {
	${6}
}
endsnippet

snippet itera "auto iterator"
for (auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
	${3:std::cout << *$1 << std::endl;}
}
endsnippet

# Lambdas
# lamda (one line)
snippet ld "lambda one line"
[${1}](${2}){${3}};
endsnippet

snippet lld "multy line lambda"
[${1}](${2}){
	${3}
};
endsnippet

# snippets exception
snippet try "try catch block"
try {

}catch(${1}) {

}
endsnippet

snippet af "auto function"
auto ${1:name}(${2}) -> ${3:void}
{
	${0}
};
endsnippet

snippet gtest "TEST(test_case_name, test_name)"
TEST(${1:test_case_name}, ${2:test_name})
{
	${0}
}
endsnippet

snippet gtestf "TEST_F(test_case_name, test_name)"
TEST_F(${1:test_fixture},${2:test_name})
{
	${0}
}
endsnippet

snippet gset "Get/Set method" 
void SetData(int data) {
	data_ = data;
}
int GetData() {
	return data_;
}
endsnippet

